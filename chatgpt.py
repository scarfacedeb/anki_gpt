import json
from openai import OpenAI
import os
import logging
from pathlib import Path
from word import Word, WordList, TAGS_ALL, WordTags
from user_settings import get_user_config


logger = logging.getLogger(__name__)

# Get API key from environment variables
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-5-nano")
OPENAI_MODEL_EFFORT = os.getenv("OPENAI_MODEL_EFFORT", "low")

def load_prompt(filename: str) -> str:
    return open(Path(__file__).parent / "prompts" / filename, 'r').read()

GET_DEFINITIONS_PROMPT_BASE = load_prompt("get_definitions_prompt.md")

EXTRACT_WORDS_PROMPT = load_prompt("extract_words_prompt.md")

def build_prompt(prompt: str, input_text: str) -> list[dict]:
    return [
        {"role": "system", "content": prompt},
        {"role": "user", "content": input_text},
    ]

def _inject_tags_into_prompt(base: str) -> str:
    """Append allowed tags guidance derived from TAGS_ALL to the base prompt."""
    tags_line = ", ".join(TAGS_ALL)
    guidance = (
        "\n\n### Allowed Tags (Autogenerated)\n"
        "- Include a `tags` array for each word.\n"
        "- Use ONLY from this fixed set (lowercase): " + tags_line + "\n"
        "- Prefer exactly one primary grammatical tag when applicable.\n"
        "- Add `inburgeringexam` when relevant for the A2 Inburgering exam contexts.\n"
        "- Add `slang` only when the usage is informal/colloquial.\n"
        "- Do NOT invent tags outside this list.\n"
    )
    return base + guidance


def get_definitions(input_text: str, user_id: int) -> WordList:
    logger.info(f"Input: {input_text}")

    config = get_user_config(user_id)

    client = OpenAI(api_key=OPENAI_API_KEY)
    prompt = _inject_tags_into_prompt(GET_DEFINITIONS_PROMPT_BASE)
    response = client.responses.parse(
        model=config.model,
        reasoning={ 'effort': config.effort },
        text_format=WordList,
        instructions=prompt,
        input=input_text,
    )

    result = response.output_parsed

    if hasattr(result, 'words') and result.words:
        for word in result.words:
            logger.info(f"Output: {word.dutch} - {word.translation}")

    return result

GENERATE_TAGS_PROMPT_BASE = load_prompt("generate_tags_prompt.md")

def generate_tags(word: Word, user_id: int) -> list[str]:
    logger.info(f"Generating tags for: {word.dutch}")

    config = get_user_config(user_id)
    client = OpenAI(api_key=OPENAI_API_KEY)

    # Build prompt with allowed tags, similar to get_definitions
    prompt = GENERATE_TAGS_PROMPT_BASE.replace("{{TAGS_ALL}}", ", ".join(TAGS_ALL))

    # Create a JSON object with the word's details for the prompt
    input_data = {
        "dutch": word.dutch,
        "translation": word.translation,
        "definition_nl": word.definition_nl,
        "definition_en": word.definition_en,
    }
    input_text = json.dumps(input_data, indent=2)

    response = client.responses.parse(
        model=config.model,
        reasoning={'effort': 'low'},  # Tagging is a low-effort task
        text_format=WordTags,
        instructions=prompt,
        input=input_text,
    )

    result = response.output_parsed
    
    if result and result.tags:
        logger.info(f"Generated tags for '{word.dutch}': {result.tags}")
        return result.tags
    
    logger.warning(f"Could not generate tags for '{word.dutch}'")
    return []



def extract_words(input_text: str) -> list[str]:
    messages = build_prompt(EXTRACT_WORDS_PROMPT, input_text)
    client = OpenAI(api_key=OPENAI_API_KEY)
    response = client.responses.create(
        model=OPENAI_MODEL,
        input=messages,
        reasoning={ 'effort': OPENAI_MODEL_EFFORT }
    )

    return response.output_text.split('; ')


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    test_input = "hond kat of vis"
    definitions = get_definitions(test_input)
    print(definitions)
